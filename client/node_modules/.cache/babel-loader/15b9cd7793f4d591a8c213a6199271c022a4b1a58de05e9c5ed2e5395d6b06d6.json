{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nfunction identity(document) {\n  return document;\n}\nvar DocumentTransform = /** @class */function () {\n  function DocumentTransform(transform, options) {\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n    this.resultCache = canUseWeakSet ? new WeakSet() : new Set();\n    this.transform = transform;\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, function (key) {\n        return {\n          key: key\n        };\n      });\n    }\n  }\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  DocumentTransform.prototype.getCacheKey = function (document) {\n    return [document];\n  };\n  DocumentTransform.identity = function () {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, {\n      cache: false\n    });\n  };\n  DocumentTransform.split = function (predicate, left, right) {\n    if (right === void 0) {\n      right = DocumentTransform.identity();\n    }\n    return new DocumentTransform(function (document) {\n      var documentTransform = predicate(document) ? left : right;\n      return documentTransform.transformDocument(document);\n    },\n    // Reasonably assume both `left` and `right` transforms handle their own caching\n    {\n      cache: false\n    });\n  };\n  DocumentTransform.prototype.transformDocument = function (document) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n    var cacheEntry = this.getStableCacheEntry(document);\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n    checkDocument(document);\n    var transformedDocument = this.transform(document);\n    this.resultCache.add(transformedDocument);\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n    return transformedDocument;\n  };\n  DocumentTransform.prototype.concat = function (otherTransform) {\n    var _this = this;\n    return new DocumentTransform(function (document) {\n      return otherTransform.transformDocument(_this.transformDocument(document));\n    },\n    // Reasonably assume both transforms handle their own caching\n    {\n      cache: false\n    });\n  };\n  DocumentTransform.prototype.getStableCacheEntry = function (document) {\n    if (!this.stableCacheKeys) return;\n    var cacheKeys = this.getCacheKey(document);\n    if (cacheKeys) {\n      invariant(Array.isArray(cacheKeys), 65);\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  };\n  return DocumentTransform;\n}();\nexport { DocumentTransform };","map":{"version":3,"mappings":"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","names":["Trie","canUseWeakMap","canUseWeakSet","checkDocument","invariant","identity","document","transform","options","Object","create","WeakSet","Set","getCacheKey","cache","stableCacheKeys","key","DocumentTransform","predicate","left","right","documentTransform","transformDocument","resultCache","has","cacheEntry","getStableCacheEntry","value","transformedDocument","add","otherTransform","_this","cacheKeys","Array","isArray","lookupArray"],"sources":["/home/greg/projects/graphql/library-frontend/node_modules/@apollo/src/utilities/graphql/DocumentTransform.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap, canUseWeakSet } from \"../common/canUse.js\";\nimport { checkDocument } from \"./getFromAST.js\";\nimport { invariant } from \"../globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  cache?: boolean;\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n\n  private readonly resultCache =\n    canUseWeakSet ? new WeakSet<DocumentNode>() : new Set<DocumentNode>();\n\n  private stableCacheKeys:\n    | Trie<{ key: DocumentTransformCacheKey; value?: DocumentNode }>\n    | undefined;\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return new DocumentTransform(\n      (document) => {\n        const documentTransform = predicate(document) ? left : right;\n\n        return documentTransform.transformDocument(document);\n      },\n      // Reasonably assume both `left` and `right` transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  constructor(\n    transform: TransformFn,\n    options: DocumentTransformOptions = Object.create(null)\n  ) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n\n    if (options.cache !== false) {\n      this.stableCacheKeys = new Trie(canUseWeakMap, (key) => ({ key }));\n    }\n  }\n\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const cacheEntry = this.getStableCacheEntry(document);\n\n    if (cacheEntry && cacheEntry.value) {\n      return cacheEntry.value;\n    }\n\n    checkDocument(document);\n\n    const transformedDocument = this.transform(document);\n\n    this.resultCache.add(transformedDocument);\n\n    if (cacheEntry) {\n      cacheEntry.value = transformedDocument;\n    }\n\n    return transformedDocument;\n  }\n\n  concat(otherTransform: DocumentTransform) {\n    return new DocumentTransform(\n      (document) => {\n        return otherTransform.transformDocument(\n          this.transformDocument(document)\n        );\n      },\n      // Reasonably assume both transforms handle their own caching\n      { cache: false }\n    );\n  }\n\n  getStableCacheEntry(document: DocumentNode) {\n    if (!this.stableCacheKeys) return;\n    const cacheKeys = this.getCacheKey(document);\n    if (cacheKeys) {\n      invariant(\n        Array.isArray(cacheKeys),\n        \"`getCacheKey` must return an array or undefined\"\n      );\n      return this.stableCacheKeys.lookupArray(cacheKeys);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}