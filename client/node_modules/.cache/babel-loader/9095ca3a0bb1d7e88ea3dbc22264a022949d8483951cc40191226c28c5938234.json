{"ast":null,"code":"import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useSubscription(subscription, options) {\n  var hasIssuedDeprecationWarningRef = React.useRef(false);\n  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  var _a = React.useState({\n      loading: !(options === null || options === void 0 ? void 0 : options.skip),\n      error: void 0,\n      data: void 0,\n      variables: options === null || options === void 0 ? void 0 : options.variables\n    }),\n    result = _a[0],\n    setResult = _a[1];\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n    if (options === null || options === void 0 ? void 0 : options.onSubscriptionData) {\n      globalThis.__DEV__ !== false && invariant.warn(options.onData ? 52 : 53);\n    }\n    if (options === null || options === void 0 ? void 0 : options.onSubscriptionComplete) {\n      globalThis.__DEV__ !== false && invariant.warn(options.onComplete ? 54 : 55);\n    }\n  }\n  var _b = React.useState(function () {\n      if (options === null || options === void 0 ? void 0 : options.skip) {\n        return null;\n      }\n      return client.subscribe({\n        query: subscription,\n        variables: options === null || options === void 0 ? void 0 : options.variables,\n        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n        context: options === null || options === void 0 ? void 0 : options.context\n      });\n    }),\n    observable = _b[0],\n    setObservable = _b[1];\n  var canResetObservableRef = React.useRef(false);\n  React.useEffect(function () {\n    return function () {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n  var ref = React.useRef({\n    client: client,\n    subscription: subscription,\n    options: options\n  });\n  React.useEffect(function () {\n    var _a, _b, _c, _d;\n    var shouldResubscribe = options === null || options === void 0 ? void 0 : options.shouldResubscribe;\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options);\n    }\n    if (options === null || options === void 0 ? void 0 : options.skip) {\n      if (!(options === null || options === void 0 ? void 0 : options.skip) !== !((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.skip) || canResetObservableRef.current) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options === null || options === void 0 ? void 0 : options.variables\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (shouldResubscribe !== false && (client !== ref.current.client || subscription !== ref.current.subscription || (options === null || options === void 0 ? void 0 : options.fetchPolicy) !== ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || !(options === null || options === void 0 ? void 0 : options.skip) !== !((_c = ref.current.options) === null || _c === void 0 ? void 0 : _c.skip) || !equal(options === null || options === void 0 ? void 0 : options.variables, (_d = ref.current.options) === null || _d === void 0 ? void 0 : _d.variables)) || canResetObservableRef.current) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options === null || options === void 0 ? void 0 : options.variables\n      });\n      setObservable(client.subscribe({\n        query: subscription,\n        variables: options === null || options === void 0 ? void 0 : options.variables,\n        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n        context: options === null || options === void 0 ? void 0 : options.context\n      }));\n      canResetObservableRef.current = false;\n    }\n    Object.assign(ref.current, {\n      client: client,\n      subscription: subscription,\n      options: options\n    });\n  }, [client, subscription, options, canResetObservableRef.current]);\n  React.useEffect(function () {\n    if (!observable) {\n      return;\n    }\n    var subscriptionStopped = false;\n    var subscription = observable.subscribe({\n      next: function (fetchResult) {\n        var _a, _b;\n        if (subscriptionStopped) {\n          return;\n        }\n        var result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data,\n          error: void 0,\n          variables: options === null || options === void 0 ? void 0 : options.variables\n        };\n        setResult(result);\n        if ((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onData) {\n          ref.current.options.onData({\n            client: client,\n            data: result\n          });\n        } else if ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client: client,\n            subscriptionData: result\n          });\n        }\n      },\n      error: function (error) {\n        var _a, _b;\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error: error,\n            variables: options === null || options === void 0 ? void 0 : options.variables\n          });\n          (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n        }\n      },\n      complete: function () {\n        var _a, _b;\n        if (!subscriptionStopped) {\n          if ((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onComplete) {\n            ref.current.options.onComplete();\n          } else if ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      }\n    });\n    return function () {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(function () {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n  return result;\n}","map":{"version":3,"mappings":"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","names":["invariant","React","equal","DocumentType","verifyDocumentType","useApolloClient","useSubscription","subscription","options","hasIssuedDeprecationWarningRef","useRef","client","Subscription","useState","loading","skip","error","data","variables","result","setResult","current","onSubscriptionData","globalThis","query","fetchPolicy","context","_b","setObservable","canResetObservableRef","ref","_a","shouldResubscribe","subscriptionStopped","observable","next","fetchResult","subscriptionData","setTimeout"],"sources":["/home/greg/projects/graphql/library-frontend/node_modules/@apollo/src/react/hooks/useSubscription.ts"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = React.useState<\n    SubscriptionResult<TData, TVariables>\n  >({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options?.onSubscriptionData) {\n      invariant.warn(\n        options.onData ?\n          \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n        : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options?.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete ?\n          \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n        : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const [observable, setObservable] = React.useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = React.useRef(false);\n  React.useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = React.useRef({ client, subscription, options });\n  React.useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (\n        !options?.skip !== !ref.current.options?.skip ||\n        canResetObservableRef.current\n      ) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(\n        client.subscribe({\n          query: subscription,\n          variables: options?.variables,\n          fetchPolicy: options?.fetchPolicy,\n          context: options?.context,\n        })\n      );\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  React.useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    let subscriptionStopped = false;\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        if (subscriptionStopped) {\n          return;\n        }\n\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        if (ref.current.options?.onData) {\n          ref.current.options.onData({\n            client,\n            data: result,\n          });\n        } else if (ref.current.options?.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client,\n            subscriptionData: result,\n          });\n        }\n      },\n      error(error) {\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error,\n            variables: options?.variables,\n          });\n          ref.current.options?.onError?.(error);\n        }\n      },\n      complete() {\n        if (!subscriptionStopped) {\n          if (ref.current.options?.onComplete) {\n            ref.current.options.onComplete();\n          } else if (ref.current.options?.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      },\n    });\n\n    return () => {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(() => {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}