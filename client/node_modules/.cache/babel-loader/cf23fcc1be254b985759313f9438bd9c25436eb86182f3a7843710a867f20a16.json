{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { equal } from \"@wry/equality\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport { createFulfilledPromise, createRejectedPromise } from \"../../utilities/index.js\";\nvar QUERY_REFERENCE_SYMBOL = Symbol();\nexport function wrapQueryRef(internalQueryRef) {\n  var _a;\n  return _a = {}, _a[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a;\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nvar OBSERVED_CHANGED_OPTIONS = [\"canonizeResults\", \"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\nvar InternalQueryReference = /** @class */function () {\n  function InternalQueryReference(observable, options) {\n    var _this = this;\n    this.listeners = new Set();\n    this.status = \"loading\";\n    this.references = 0;\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    if (isNetworkRequestSettled(this.result.networkStatus) || this.result.data && (!this.result.partial || this.watchQueryOptions.returnPartialData)) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise(function (resolve, reject) {\n        _this.resolve = resolve;\n        _this.reject = reject;\n      });\n    }\n    this.subscription = observable.filter(function (_a) {\n      var data = _a.data;\n      return !equal(data, {});\n    }).subscribe({\n      next: this.handleNext,\n      error: this.handleError\n    });\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    var startDisposeTimer = function () {\n      var _a;\n      if (!_this.references) {\n        _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n      }\n    };\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  Object.defineProperty(InternalQueryReference.prototype, \"watchQueryOptions\", {\n    get: function () {\n      return this.observable.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InternalQueryReference.prototype.retain = function () {\n    var _this = this;\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    var disposed = false;\n    return function () {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      _this.references--;\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(function () {\n        if (!_this.references) {\n          _this.dispose();\n        }\n      });\n    };\n  };\n  InternalQueryReference.prototype.didChangeOptions = function (watchQueryOptions) {\n    var _this = this;\n    return OBSERVED_CHANGED_OPTIONS.some(function (option) {\n      return !equal(_this.watchQueryOptions[option], watchQueryOptions[option]);\n    });\n  };\n  InternalQueryReference.prototype.applyOptions = function (watchQueryOptions) {\n    var _a = this.watchQueryOptions,\n      currentFetchPolicy = _a.fetchPolicy,\n      currentCanonizeResults = _a.canonizeResults;\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n    return this.promise;\n  };\n  InternalQueryReference.prototype.listen = function (listener) {\n    var _this = this;\n    this.listeners.add(listener);\n    return function () {\n      _this.listeners.delete(listener);\n    };\n  };\n  InternalQueryReference.prototype.refetch = function (variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  };\n  InternalQueryReference.prototype.fetchMore = function (options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  };\n  InternalQueryReference.prototype.dispose = function () {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  };\n  InternalQueryReference.prototype.onDispose = function () {\n    // noop. overridable by options\n  };\n  InternalQueryReference.prototype.handleNext = function (result) {\n    var _a;\n    switch (this.status) {\n      case \"loading\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          this.status = \"idle\";\n          this.result = result;\n          (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, result);\n          break;\n        }\n      case \"idle\":\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data) {\n            return;\n          }\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n          break;\n        }\n    }\n  };\n  InternalQueryReference.prototype.handleError = function (error) {\n    var _a;\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);\n    switch (this.status) {\n      case \"loading\":\n        {\n          this.status = \"idle\";\n          (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, error);\n          break;\n        }\n      case \"idle\":\n        {\n          this.promise = createRejectedPromise(error);\n          this.deliver(this.promise);\n        }\n    }\n  };\n  InternalQueryReference.prototype.deliver = function (promise) {\n    this.listeners.forEach(function (listener) {\n      return listener(promise);\n    });\n  };\n  InternalQueryReference.prototype.initiateFetch = function (returnedPromise) {\n    var _this = this;\n    this.status = \"loading\";\n    this.promise = new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    });\n    this.promise.catch(function () {});\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise.then(function (result) {\n      var _a;\n      if (_this.status === \"loading\") {\n        _this.status = \"idle\";\n        _this.result = result;\n        (_a = _this.resolve) === null || _a === void 0 ? void 0 : _a.call(_this, result);\n      }\n    }).catch(function () {});\n    return returnedPromise;\n  };\n  return InternalQueryReference;\n}();\nexport { InternalQueryReference };","map":{"version":3,"mappings":"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","names":["equal","isNetworkRequestSettled","createFulfilledPromise","createRejectedPromise","QUERY_REFERENCE_SYMBOL","Symbol","wrapQueryRef","internalQueryRef","_a","unwrapQueryRef","queryRef","OBSERVED_CHANGED_OPTIONS","observable","options","Set","handleNext","bind","handleError","dispose","result","getCurrentResult","key","onDispose","networkStatus","data","partial","watchQueryOptions","returnPartialData","promise","status","Promise","resolve","reject","_this","subscription","filter","subscribe","next","error","startDisposeTimer","references","autoDisposeTimeoutId","setTimeout","autoDisposeTimeoutMs","then","Object","InternalQueryReference","clearTimeout","disposed","some","option","currentFetchPolicy","currentCanonizeResults","fetchPolicy","initiateFetch","reobserve","silentSetOptions","canonizeResults","listener","listeners","add","delete","variables","refetch","fetchMore","unsubscribe","deliver","resubscribeAfterError","forEach","returnedPromise","catch"],"sources":["/home/greg/projects/graphql/library-frontend/node_modules/@apollo/src/react/cache/QueryReference.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../utilities/index.js\";\nimport type { CacheKey } from \"./types.js\";\nimport type { useBackgroundQuery, useReadQuery } from \"../hooks/index.js\";\n\ntype Listener<TData> = (promise: Promise<ApolloQueryResult<TData>>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\n/**\n * A `QueryReference` is an opaque object returned by {@link useBackgroundQuery}.\n * A child component reading the `QueryReference` via {@link useReadQuery} will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown> {\n  [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n}\n\ninterface InternalQueryReferenceOptions {\n  key: CacheKey;\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData>(\n  internalQueryRef: InternalQueryReference<TData>\n): QueryReference<TData> {\n  return { [QUERY_REFERENCE_SYMBOL]: internalQueryRef };\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result: ApolloQueryResult<TData>;\n  public readonly key: CacheKey;\n  public readonly observable: ObservableQuery<TData>;\n\n  public promiseCache?: Map<CacheKey, Promise<ApolloQueryResult<TData>>>;\n  public promise: Promise<ApolloQueryResult<TData>>;\n\n  private subscription: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n  private status: \"idle\" | \"loading\" = \"loading\";\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n\n  constructor(\n    observable: ObservableQuery<TData>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    if (\n      isNetworkRequestSettled(this.result.networkStatus) ||\n      (this.result.data &&\n        (!this.result.partial || this.watchQueryOptions.returnPartialData))\n    ) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n    }\n\n    this.subscription = observable\n      .filter(({ data }) => !equal(data, {}))\n      .subscribe({\n        next: this.handleNext,\n        error: this.handleError,\n      });\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.status) {\n      case \"loading\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.status = \"idle\";\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      case \"idle\": {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (result.data === this.result.data) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.status) {\n      case \"loading\": {\n        this.status = \"idle\";\n        this.reject?.(error);\n        break;\n      }\n      case \"idle\": {\n        this.promise = createRejectedPromise(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: Promise<ApolloQueryResult<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.status = \"loading\";\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then((result) => {\n        if (this.status === \"loading\") {\n          this.status = \"idle\";\n          this.result = result;\n          this.resolve?.(result);\n        }\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}